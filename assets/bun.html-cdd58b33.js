import{_ as n,r as a,o as r,c as s,b as e,d as l,e as o,a as t}from"./app-4f7908e3.js";const u={},d=e("h1",{id:"bun",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#bun","aria-hidden":"true"},"#"),l(" Bun")],-1),c=e("h2",{id:"初识bun",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#初识bun","aria-hidden":"true"},"#"),l(" 初识Bun")],-1),h={href:"https://github.com/oven-sh/bun",target:"_blank",rel:"noopener noreferrer"},p=e("strong",null,"颠覆js生态系统",-1),b=t('<p>Bun的优势：</p><ul><li>提供比Node或者Deno<strong>更快</strong>的运行时</li><li>包管理器比npm或者yarn<strong>快</strong>上亿倍</li><li>browser bundler——能替代webpack到react-scripts的所有内容，速度<strong>快如闪电</strong>（esbuild呢？）</li><li>提供速度<strong>很快</strong>的webserver(代替Express)</li><li>Sqlite 客户端</li><li>Bread</li></ul><p>思路：Js拥有的我要有，而且我要更简单、更高效。用一种低级语言，编写出运行极快的代码，这就是Bun。但是Bun还很年轻，但是势头很猛，We&#39;ll see.</p><h2 id="现如今js的困境" tabindex="-1"><a class="header-anchor" href="#现如今js的困境" aria-hidden="true">#</a> 现如今Js的困境</h2><p>拼了命的东拼西凑的js环境</p><ul><li>例如：Ts在涉及到多位开发者的项目中解决了不少难题，感谢微软</li><li>例如：Npm在大型项目和单体Repo速度太慢，Yarn某种程度上解决了速度问题，感谢Facebook</li><li>再例如：Yarn3的”即插即用“节点模块虚拟化来替代NPM</li><li>再例如：JSON schema的请求解析器解决了Express的低速问题</li></ul><p>都在用js解决js的问题，<strong>用JS编写就是慢</strong></p><p>品一品，想一想，Webpack慢，于是有了Go语言的esbuild，eslint的替代方案也有了，通过Rust重写了Rome。</p><p>Bun就在这个趋势中自然延续，但是从下往上的推进思路，从零起步、以内置”batteries“的方式，用低语言重写整个JS生态系统。</p><h2 id="到目前为止-bun可以做什么呢" tabindex="-1"><a class="header-anchor" href="#到目前为止-bun可以做什么呢" aria-hidden="true">#</a> 到目前为止，Bun可以做什么呢？</h2><ul><li>让解释器快起来</li></ul><ol><li>Zig(C++) + JavaScriptCore(Apple)，一起归功于Zig这门语言的速度</li><li>支持90%的Node Api</li><li>支持对ts的解析</li></ol><ul><li>替代NPM</li></ul><ol><li>与NPM的思路雷同，独有的lockfile格式，同时node_modules和package.json看起来也没什么变化</li><li>通过文件系统的<strong>低级访问</strong>和<strong>快速语言</strong>实现极快的安装效果</li><li>但是不支持更强地工作空间，但是已经在规划中。</li></ol><ul><li>内含转译器，矛头指向webpack、esbuild</li></ul><ol><li>包含一个用于网络浏览器的转译器，bun中的解析器就是esbuild解析器的一个Zig端口</li><li>内置项目脚手架，通过<code>bun create react my-app</code>和<code>bun dev</code>可以轻松启动一个react项目</li><li>生产环境的方面路还很长</li></ol><ul><li>其他功能——web server和Sqlite客户端</li></ul><ol><li>与现有的功能基本持平，但是某些条件下更好用</li></ol><h2 id="发展阻碍" tabindex="-1"><a class="header-anchor" href="#发展阻碍" aria-hidden="true">#</a> 发展阻碍</h2><ul><li>转变的巨大</li><li>Bun太年轻</li></ul><h2 id="开源世界中的生态阵营" tabindex="-1"><a class="header-anchor" href="#开源世界中的生态阵营" aria-hidden="true">#</a> 开源世界中的生态阵营</h2><ul><li>Jest Vs Mocha</li></ul><p>Mocha痛点：稍微复杂的需求都需要引入其他模块和插件</p><p>Jest的优点：所有的能力整合到了单一框架中，慢慢也就变成了更受欢迎的框架</p><p>也许Bun就是Jest，虽然这不符合开源精神，但是确实实实在在地解决了开发者的痛点。</p><h2 id="我们可以借鉴的是什么" tabindex="-1"><a class="header-anchor" href="#我们可以借鉴的是什么" aria-hidden="true">#</a> 我们可以借鉴的是什么</h2><ul><li>js中的好多问题都是通过js解决，大型项目中效果甚微</li><li>学习新的语言才能更好的解决本质问题，基于语言本身的性能</li><li>将来做优化可以直接借鉴或部分借鉴其他语言的工具包（esbuild, bun）</li><li>或许Bun会在接下来取代Js生态，可以了解和学习</li><li>基于Bun共建一些符合我们业务场景中的工具，不用很全，够我们用就好</li></ul>',27);function _(g,f){const i=a("ExternalLinkIcon");return r(),s("div",null,[d,c,e("p",null,[e("a",h,[l("Bun"),o(i)]),l("通过Zig编程语言开发的运行时，起初是种Javascript webserver，后续的发展中酝酿出"),p,l("的野心。")]),b])}const m=n(u,[["render",_],["__file","bun.html.vue"]]);export{m as default};
