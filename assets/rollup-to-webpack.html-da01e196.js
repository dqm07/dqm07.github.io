import{_ as e,o as a,c as i,a as l}from"./app-4f7908e3.js";const r={},d=l('<h1 id="rollup迁移webpack4" tabindex="-1"><a class="header-anchor" href="#rollup迁移webpack4" aria-hidden="true">#</a> rollup迁移webpack4</h1><h2 id="为何要迁移" tabindex="-1"><a class="header-anchor" href="#为何要迁移" aria-hidden="true">#</a> 为何要迁移</h2><ul><li>工具本身属于业务逻辑模块（字体、图片甚至视频）</li><li>rollup定位</li><li>rollup本身生态环境的限制</li><li>webpack强大生态</li><li>便于扩展和使用</li></ul><h2 id="现状分析" tabindex="-1"><a class="header-anchor" href="#现状分析" aria-hidden="true">#</a> 现状分析</h2><h3 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么" aria-hidden="true">#</a> 是什么？</h3><p>工具本身特性：Container + Component；Vue项目</p><h3 id="rollup都做了什么" tabindex="-1"><a class="header-anchor" href="#rollup都做了什么" aria-hidden="true">#</a> rollup都做了什么</h3><blockquote><p>截图对比</p></blockquote><h3 id="有何差异" tabindex="-1"><a class="header-anchor" href="#有何差异" aria-hidden="true">#</a> 有何差异？</h3><ul><li>replace vs webpack.DefinePlugin</li><li>vue vs vue-loader</li><li>postcss vs css-loader|less-loader</li><li>json</li><li>nodeResolve vs resolve</li><li>commonjs</li><li>eslint</li><li>babel vs bable-loader</li><li>image vs url-loader</li><li>serve vs devServer</li><li>watch vs HMR(inline/hot)</li><li>uglify</li><li>minify</li></ul><h2 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题" aria-hidden="true">#</a> 遇到的问题</h2><h3 id="引用文件省略了后缀" tabindex="-1"><a class="header-anchor" href="#引用文件省略了后缀" aria-hidden="true">#</a> 引用文件省略了后缀</h3><p><code>resolve</code></p><h3 id="elementui并没有引用执行" tabindex="-1"><a class="header-anchor" href="#elementui并没有引用执行" aria-hidden="true">#</a> elementUI并没有引用执行</h3><p><code>externals</code></p><h3 id="vue文件处理" tabindex="-1"><a class="header-anchor" href="#vue文件处理" aria-hidden="true">#</a> .vue文件处理</h3><p><code>vue-loader</code> and <code>VueLoaderPlugin</code></p><h3 id="ismock" tabindex="-1"><a class="header-anchor" href="#ismock" aria-hidden="true">#</a> ISMOCK</h3><p><code>webpack.DefinePlugin</code></p><h3 id="逻辑处理" tabindex="-1"><a class="header-anchor" href="#逻辑处理" aria-hidden="true">#</a> 逻辑处理</h3><p><code>HtmlWebpackPlugin</code>解决多个文件引用问题</p><h3 id="启动多个工具的时候" tabindex="-1"><a class="header-anchor" href="#启动多个工具的时候" aria-hidden="true">#</a> 启动多个工具的时候</h3><p><code>portfinder</code>的作用，自动递增端口号，正常打开页面进行调试</p><h3 id="一个比较有意思的处理" tabindex="-1"><a class="header-anchor" href="#一个比较有意思的处理" aria-hidden="true">#</a> 一个比较有意思的处理</h3><p><code>AddExtraSourcePlugin</code>来完善需要的功能补充</p><p>一张图来解释工具gptool-core包的问题，以及在rollup里的处理办法，webpack暂时没办然绕过这个逻辑，那么需要手动在文件打包的时候增加这样一段代码，因此开发了一个插件使用。</p><ul><li>打包的问题有默认default</li><li>如何引用这样一段代码</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><code>配置项目千变万化，配置套路千篇一律</code></p><p>webpack的默认能力很强大，且生态较为完善，因约定而规范，但也因约定而带来迁移成本。</p><p>rollup默认能力一般，工具包构建生态不能应用更多其他场景，但是灵活代码简单。</p>',31),h=[d];function o(c,n){return a(),i("div",null,h)}const t=e(r,[["render",o],["__file","rollup-to-webpack.html.vue"]]);export{t as default};
