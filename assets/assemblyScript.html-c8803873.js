import{_ as e,o as s,c as a,a as i}from"./app-4f7908e3.js";const l={},r=i('<h1 id="assemblyscript" tabindex="-1"><a class="header-anchor" href="#assemblyscript" aria-hidden="true">#</a> AssemblyScript</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>WebAssembly(Wasm) 浏览器低级语言，它使得网站代码可以再安全的沙盒环境中以接近本机的速度运行。</p><ul><li>二进制交付</li><li>大小体积</li><li>加载时长</li></ul><p>目标：不是取代Js，至少目前还没有访问DOM的能力，而是把WebAssembly看作是<code>与现有Web平台良好集成的新工具</code></p><p>应用场景：</p><ul><li>游戏</li><li>可视化</li><li>CAD应用</li><li>图像/视频编辑</li></ul><p>通用特点：CPU密集型任务提供接近本机的性能，让一些程序迁移至Web成为可能。（Figma这种网站提速）</p><p>前端如何来用呢？手写Wasm当然可以，但是这种低级语言是成为其他语言（C/C++/GO/Rust）的编译目标的，最终变成了学习一门后端语言。前端怎么可以快速上手并运用呢？AssemblyScript就是为了解决这个问题而产生的。</p><p><code>AssemblyScript</code>是一个把Ts转换为WebAssembly的编译器。但是只支持了Ts的部分能力，但是写法上跟Js极为相似，因此Web开发人员上手会变得更加容易。</p><h2 id="上手demo" tabindex="-1"><a class="header-anchor" href="#上手demo" aria-hidden="true">#</a> 上手Demo</h2><p>refer links: https://www.assemblyscript.org/getting-started.html#setting-up-a-new-project</p><h2 id="一些关于assemblyscript的疑问" tabindex="-1"><a class="header-anchor" href="#一些关于assemblyscript的疑问" aria-hidden="true">#</a> 一些关于AssemblyScript的疑问</h2><h3 id="assemblyscript最终会完全支持ts吗" tabindex="-1"><a class="header-anchor" href="#assemblyscript最终会完全支持ts吗" aria-hidden="true">#</a> AssemblyScript最终会完全支持Ts吗？</h3><p>一些功能不能提前编译中支持，但是严格模式下的ts可以兼容需求</p><h3 id="assemblyscript的运用场景" tabindex="-1"><a class="header-anchor" href="#assemblyscript的运用场景" aria-hidden="true">#</a> AssemblyScript的运用场景</h3><ul><li>镜像处理</li><li>游戏逻辑</li><li>特殊算法</li><li>模拟器</li><li>编译器等</li></ul><h3 id="assemblyscript可以在浏览器之外运行吗" tabindex="-1"><a class="header-anchor" href="#assemblyscript可以在浏览器之外运行吗" aria-hidden="true">#</a> AssemblyScript可以在浏览器之外运行吗</h3><p>当然可以，只要载体支持WebAssembly就可以</p>',19),t=[r];function c(d,h){return s(),a("div",null,t)}const b=e(l,[["render",c],["__file","assemblyScript.html.vue"]]);export{b as default};
