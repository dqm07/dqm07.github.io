import{_ as i,o as l,c as e,a as o}from"./app-4f7908e3.js";const r={},a=o('<h1 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> Vite</h1><h2 id="why-vite" tabindex="-1"><a class="header-anchor" href="#why-vite" aria-hidden="true">#</a> why vite</h2><p>bundler的形式（webpack）比较慢，每次修改都需要重复构建很多无意义的文件。而且随着项目的扩大，其中构建的速度就越来越慢。</p><p>因此诞生了Vite，通过浏览器对于native ESM的特性支持和esbuild的构建能力（go语言实现），极大程度上提升了构建效率。</p><h2 id="comparisons-with-other-no-bundler-solutions" tabindex="-1"><a class="header-anchor" href="#comparisons-with-other-no-bundler-solutions" aria-hidden="true">#</a> comparisons with other no-bundler solutions</h2><ul><li>snowpack <ul><li>differ in prod: vite is more fluent(focus on rollup), snowpack adapt to more build terminal</li><li>no pre-bundling</li><li>monorepo is supported in vite</li><li>css compile is supported in vite</li><li>first class vue support</li></ul></li><li>wmr <ul><li>only for preact</li><li>others framework is not friendly</li></ul></li><li>@web/dev-server <ul><li>vite 1.0 server is inspired by this</li><li>it&#39;s low-level, no framework</li><li>vite aims to provides out-of-the-box workflow</li></ul></li></ul><h2 id="what-about-1-0" tabindex="-1"><a class="header-anchor" href="#what-about-1-0" aria-hidden="true">#</a> what about 1.0</h2><p>起初是解决.vue文件能够在浏览器能够被直接加载执行，那么怎么做呢？@vue/vue-dev-server （ all rollup ）</p><ul><li>浏览器直接请求import文件，没有bundler</li><li>服务端拦截.vue文件，运行时编译返回可执行的js</li><li>对于依赖库支持module格式的直接引用cdn</li><li>对于js文件里的引用包的（只有包名），重写引用方式，直接指向本地已安装的文件</li></ul><h2 id="what-s-new-in-2-0" tabindex="-1"><a class="header-anchor" href="#what-s-new-in-2-0" aria-hidden="true">#</a> what&#39;s new in 2.0</h2><p>相较于之前的版本，2.0算是真正意义上的稳定版本，这里面做了很多重构，做了很多改善。</p><ul><li>更多框架的支持，不再只是.vue单文件组件，因为vite提供了模板，因此解析只是扩展的形式</li><li>新的插件形式和api <ul><li>继承自rollup插件并兼容很多的rollup插件</li><li>增强了rollup的能力，提供了额外的api支持干预打包流程</li></ul></li><li>dependency pre-bundling with esbuild <ul><li>fast: cus esbuild in go language</li><li>dependency pre-bundling <ul><li>one dependency belongs to one file</li><li>convert commonjs &amp; umd to ESM</li></ul></li></ul></li><li>头等css支持 <ul><li>css分离，且在js加载的同时并行加载对应的css文件</li><li>支持@import 和 url()解析</li></ul></li><li>ssr的支持</li><li>老版本浏览器的支持 @vitejs/plugin-legacy</li></ul><h2 id="what-i-concerned-生产环境的处理" tabindex="-1"><a class="header-anchor" href="#what-i-concerned-生产环境的处理" aria-hidden="true">#</a> what i concerned 生产环境的处理</h2><ul><li>build <ul><li>兼容：dynamic import polyfill &amp; @vitejs/plugin-legacy</li><li>public path cloud be handle by developer</li><li>自定义build.rollupOptions</li><li>多页支持</li><li>lib mode，支持发布成依赖库</li></ul></li><li>build优化 <ul><li>动态引入轻量级的import polyfill，兼容module模块对于浏览器的支持，不支持module的需要额外的工具</li><li>css分割独立成文件，会在js文件加载的时候加载相应地css，当然你可以将css合并一个</li><li>link自动集成modulepreload</li><li>preload common模块，并且trace所有的直接引用模块，减少公共模块的引用次数，减少请求和打包体量</li></ul></li></ul>',14),n=[a];function t(s,u){return l(),e("div",null,n)}const c=i(r,[["render",t],["__file","vite.html.vue"]]);export{c as default};
