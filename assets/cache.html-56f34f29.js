import{_ as e,o as i,c as a,a as t}from"./app-4f7908e3.js";const o={},r=t('<h1 id="前端缓存" tabindex="-1"><a class="header-anchor" href="#前端缓存" aria-hidden="true">#</a> 前端缓存</h1><h2 id="缓存规则" tabindex="-1"><a class="header-anchor" href="#缓存规则" aria-hidden="true">#</a> 缓存规则</h2><ul><li><p>强缓存</p><p>优先级高于协商缓存，与之相关联的属性有两个：Expires 和 Cache-Control。</p><ul><li><p>Expires</p><p>值为到期时间点，每次请求拿这个值判定过期与否，进而判定是否走缓存。这个的问题在于<strong>不同时区的时间存在误差</strong></p></li><li><p>Cache-Control</p><p>值为到期剩下的时间，相对于时间点更为准确，到期后直接走网络请求，否则走缓存</p></li></ul></li><li><p>协商缓存</p><p>如果同时设定了强缓存和协商缓存，协商缓存是不生效的，与之关联的属性也有两个：Last-Modified/If-Modified-Since 和 Etag/If-None-Match。</p><ul><li><p>Last-Modified/If-Modified-Since</p><p>顾名思义，属性值为上次文件修改的时间点，Last-Modified 来自 response header, 而下次请求资源的时候 request header 会通过 If-Modified-Since 将上次得到的时间点带给服务端，服务端判定是否更新来确认是否返回新资源。这个属性的问题是<strong>时间的最小单位是秒级别，秒级以下的更新不能敏锐命中</strong></p></li><li><p>Etag/If-None-Match</p><p>为了解决上述的问题，该属性的值为唯一标识，进而解决了秒级以下的更新问题。etag 属性来自 response header，If-None-Match 是下次请求的 request header 属性。该属性的优先级高于 Last-Modified</p></li></ul></li></ul>',3),d=[r];function s(c,n){return i(),a("div",null,d)}const l=e(o,[["render",s],["__file","cache.html.vue"]]);export{l as default};
