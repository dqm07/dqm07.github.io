import{_ as l,o as i,c as e,a as u}from"./app-4f7908e3.js";const a={},t=u('<h1 id="知识整理" tabindex="-1"><a class="header-anchor" href="#知识整理" aria-hidden="true">#</a> 知识整理</h1><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h2><h3 id="react的发展历程" tabindex="-1"><a class="header-anchor" href="#react的发展历程" aria-hidden="true">#</a> React的发展历程</h3><ul><li>React &lt; 16.8 <ul><li>传统的集中setState进行更新状态，一气呵成，阻塞主流程，进而影响页面卡顿</li><li>提供给开发者scu、pureComponent、useMemo、useCallback等给开发者进行性能优化</li><li>原因是Jsx的灵活导致了react没办法规范优化</li><li>diff算法 <ul><li>基于策略 <ul><li>tree diff</li><li>component diff <ul><li>scu</li></ul></li><li>element diff <ul><li>add、remove、move</li></ul></li></ul></li></ul></li><li>react生命周期</li></ul></li><li>React 16.8 <ul><li>fiber的产生 <ul><li>可中断、更小粒度的渲染/更新过程</li><li>浏览器空闲执行requestIdleCallback</li><li>结果汇总patch到真实dom</li></ul></li><li>fiber原理 <ul><li>diff + patch，diff是逻辑计算，可中断；而patch不可中断</li><li>fiber tree跟实际的vDom tree一样，携带的信息有差异（简单的节点结构关系和存储信息变量）</li><li>具体实现 <ul><li>生成fiber tree，fiber节点上的信息（parent/child/nextsibling/effect list/side effect等）</li><li>深度优先遍历fiber tree</li><li>调用reconciliation</li><li>effect list &amp; side effect</li></ul></li><li>中断&amp;恢复 <ul><li>中断，在requestIdleCallback执行完立刻暂存数据，并打上tag，并启动下一次requestIdleCallback</li><li>恢复，通过tag识别需要恢复的内容，并判定是否需要继续或者重新计算</li></ul></li></ul></li><li>hooks <ul><li>解决功能复用的问题，对立于class组件的特性</li><li>原理 <ul><li>举例useState：本质上就是维护两个数组，因为每次重新渲染都是重新从数组头部开始，因此顺序很重要</li></ul></li><li>原则 <ul><li>循环、条件语句不可以使用hooks</li><li>只能在函数式组件里使用</li></ul></li></ul></li><li>TypeScript <ul><li>静态语言有了类型的概念，增强了js语言</li><li>更适合在底层或者长期稳定的业务项目中去推广，最大程度的发挥类型语言带来的优势——便于维护、错误前置</li><li>经典的ts的原理 <ul><li>record typeof Record&lt;K extends keyof any, T&gt; = { [P in K]: T }</li></ul></li></ul></li></ul></li><li>React 17 <ul><li>reconciliation算法升级，细化了更新的优先级，提出了车道模式，同一类型的异步放在一个车道里，且优先级高的车道先清空</li><li>技术改造的过渡版本（17+以后的版本可以混用，也是因为15到16的改造成本过高导致）</li><li>事件委托从document改到了渲染react树的根dom容器中</li></ul></li><li>React 18 <ul><li>渐进升级，减少升级痛苦</li><li>新特性 <ul><li>新的root api，并发渲染</li><li>自动batching，更新更细致，异步处理结果的更新也会batching，存在一个开关可以控制</li><li>异步的setState也会合并，相较于之前的只会合并生命周期内的相比</li><li>suspense的优化，达到真正意义上的预测性，老版本只是做了display:hidden</li><li>ssr可打破串行的规律</li><li>startTransition提供更优雅的异步能来，参考fiber可以中断思路，同时优先于setTimeout执行，默认做了transition标记</li></ul></li></ul></li></ul><h3 id="状态管理" tabindex="-1"><a class="header-anchor" href="#状态管理" aria-hidden="true">#</a> 状态管理</h3><ul><li>redux vs mobx vs vuex <ul><li>mobx成本低，装饰器的方案，多个局部store，面向对象编程，可以修改状态。不推荐运用到复杂工程里，因为过于自由的开发方式，维护是个成本</li><li>redux成本高，全局store，可运用到大型工程里，状态不可变，都是返回一个新的状态</li><li>vuex跟redux类似，都是基于flux，运用在vue项目中，使用方式上有一些差异，可以修改状态</li></ul></li></ul><h2 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h2><h3 id="vue的发展历程" tabindex="-1"><a class="header-anchor" href="#vue的发展历程" aria-hidden="true">#</a> Vue的发展历程</h3><ul><li>Vue2.0 <ul><li>响应式原理 <ul><li>观察者模式</li></ul></li><li>diff算法 <ul><li>首位交叉对比法则</li><li>考虑含有key的情况下的优化思路</li></ul></li></ul></li><li>Vue3.0 <ul><li>更快-diff算法</li><li>更小-实际加载更小</li><li>新特性 <ul><li>多个根节点问题</li><li>拉齐自定义api</li><li>teleport</li><li>createApp</li></ul></li><li>useRef &amp; useReactive <ul><li>互为补充，仅仅是提供了一种书写风格</li></ul></li><li>composition api <ul><li>逻辑复用</li></ul></li></ul></li></ul><h2 id="js" tabindex="-1"><a class="header-anchor" href="#js" aria-hidden="true">#</a> Js</h2><ul><li>原型与继承 <ul><li>原型产生的背景：解决继承的问题</li><li>组合继承最优</li></ul></li><li>设计模式 <ul><li>观察者模式</li><li>发布订阅模式</li></ul></li><li>深拷贝 <ul><li>浅拷贝，基础类型拷贝，引用类型不拷贝</li><li>JSON.parse(Json.stringify(obj))，不能解决互相调用的问题</li><li>实现深拷贝，解决互相引用的问题（weakMap/weakSet）</li></ul></li><li>浏览器渲染机制 <ul><li>浏览器发起一次dns域名解析请求 <ul><li>先查看本地浏览器缓存</li><li>查找服务器缓存</li><li>查询到域名返回</li></ul></li><li>浏览器拿到ip进行真实的资源请求 <ul><li>简历tcp链接，三次握手 <ul><li>发起请求，需要建立连接</li><li>服务器响应确认</li><li>客户端发起确认消息，建立连接</li></ul></li><li>请求html资源</li><li>返回浏览器进行Html解析 <ul><li>生产dom树</li><li>生成cssom树</li><li>请求js资源，这会阻塞渲染 <ul><li>合并dom树和cssom树为render树</li><li>将render树进行渲染并绘制到浏览器中</li></ul></li></ul></li></ul></li></ul></li><li>Promise实现原理 <ul><li>then的入参可能是Promise</li><li>resolve的value可能是Promise</li><li>数组的存在是支持异步</li></ul></li><li>柯里化 <ul><li>递归</li></ul></li></ul><h2 id="ts" tabindex="-1"><a class="header-anchor" href="#ts" aria-hidden="true">#</a> Ts</h2><ul><li>Type 与 Interface的区别</li><li>unknown 和 never <ul><li>any 和 void</li></ul></li></ul><h2 id="微前端" tabindex="-1"><a class="header-anchor" href="#微前端" aria-hidden="true">#</a> 微前端</h2><ul><li>qiankun</li><li>ModuleFederation</li></ul><h2 id="工程化" tabindex="-1"><a class="header-anchor" href="#工程化" aria-hidden="true">#</a> 工程化</h2><ul><li>Webpack <ul><li>生命周期 <ul><li>合并参数</li><li>初始化环境（tapable管理插件）</li><li>compile方法进行入口分析</li><li>依赖分析（深度/广度都行）</li><li>运用Loader（less到style的过程）</li><li>产出文件，seal阶段整合代码</li><li>合并webpack代码</li><li>进入封装打包，大量执行plugin的过程</li><li>module的格式支持</li><li>asset阶段产出实际内容输出</li></ul></li><li>优化方案 <ul><li>DLL</li><li>HappyPack</li><li>Hard Source</li><li>scope hosting将重复的函数合并成一个</li><li>SWC</li><li>esbuild</li></ul></li><li>loader &amp; plugin</li><li>热加载原理 <ul><li>sockjs</li><li>jsonp</li><li>HotModuleReplacementTemplate</li><li>JsonpTemplate</li></ul></li></ul></li><li>Vite <ul><li>核心思想：ESM浏览器 + esbuild的构建能力（go language）</li><li>1.0版本 <ul><li>解决的是.vue文件的加载更新问题 <ul><li>直接import文件</li><li>服务器拦截.vue文件，返回可执行js</li><li>依赖库的支持主要是引用cdn和本地已安装文件</li></ul></li></ul></li><li>2.0版本 <ul><li>不再简单支持.vue文件，而是支持更多框架</li><li>扩展更多能力，例如预打包，js和css同步加载等</li></ul></li><li>在Shopee中的运用</li></ul></li></ul><h2 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> Node</h2><ul><li>node的执行机制 <ul><li>timer</li><li>I/O callback</li><li>Idle/Prepare</li><li>poll 核心</li><li>check setImmediate</li><li>close callback</li></ul></li><li>洋葱模型 <ul><li>手写洋葱模型，本质是递归调用Promise.resolve()</li></ul></li><li>egg框架</li><li>Nest.js</li><li>服务端的稳定性</li><li>进程与线程 <ul><li>process</li><li>cluster &amp; child-process 通过fork实现进程的生成</li><li>IPC 实现进程之间的通信，全部通过master来转接</li></ul></li><li>child_process &amp; cluster <ul><li>folk出子进程</li><li>cluster通过folk批量生产子进程</li></ul></li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li>性能优化 <ul><li>lighthouse <ul><li>用户感知的优化才是真的好的优化 <ul><li>ttl</li><li>Lcp</li><li>fcp 25</li><li>sl</li><li>tbt 25</li><li>cls</li></ul></li></ul></li><li>首屏 <ul><li>首屏dom元素加载完毕后的时间</li></ul></li><li>白屏 <ul><li>head标签加载完毕时间</li></ul></li></ul></li><li>安全与网络 <ul><li>http status</li><li>cookie <ul><li>httponly: 不能被js修改</li><li>secure: https xss</li></ul></li><li>xss js注入-转义就好</li><li>csrf 跨站伪造请求-生成随机数即可</li><li>点击劫持 <ul><li>X-Frame-Options 设置iframe的加载规范，进而避免恶意的劫持</li><li>img浮出</li></ul></li><li>缓存原则 <ul><li>etag的出现是为了兜底，秒级别以下的监控</li><li>协商缓存</li></ul></li></ul></li><li>Nginx &amp; linux命令 <ul><li>linux <ul><li>tail -f xxx.log</li><li>cat -n xxx.log | grep &#39;keyword&#39;</li><li>ps aux | grep nginx</li><li>kill -9 id</li></ul></li><li>nginx <ul><li>静态资源服务器</li><li>负载均衡</li><li>转发代理</li><li>中间层处理</li></ul></li></ul></li></ul><h2 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h2><ul><li>数组中双指针优于遍历，有序数组更优，二分处理，滑动窗口</li><li>进制问题都是位移问题</li><li>链表中充分利用next和哑巴节点，环状处理</li><li>组合问题都是动态规划，背包问题 <ul><li>寻找子问题</li><li>建立边界条件，核心回溯</li><li>返回结果</li></ul></li><li>任何不清楚的问题分两类 <ul><li>寻找子问题，做动态规划</li><li>寻找规律</li></ul></li></ul>',23),r=[t];function s(d,c){return i(),e("div",null,r)}const n=l(a,[["render",s],["__file","knowledge.html.vue"]]);export{n as default};
