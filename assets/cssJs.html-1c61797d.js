import{_ as s,o as i,c as e,a}from"./app-4f7908e3.js";const l={},n=a('<h1 id="css-in-js-vs-js-in-css" tabindex="-1"><a class="header-anchor" href="#css-in-js-vs-js-in-css" aria-hidden="true">#</a> css in js VS js in css</h1><h2 id="css-in-js" tabindex="-1"><a class="header-anchor" href="#css-in-js" aria-hidden="true">#</a> css in js</h2><h3 id="import-css-in-js" tabindex="-1"><a class="header-anchor" href="#import-css-in-js" aria-hidden="true">#</a> import css in js</h3><ul><li>deal with webpack loader</li></ul><h3 id="styled-components" tabindex="-1"><a class="header-anchor" href="#styled-components" aria-hidden="true">#</a> styled components</h3><ul><li>适合订制主题</li><li>with react components</li><li>用js的思路写css</li></ul><h4 id="features" tabindex="-1"><a class="header-anchor" href="#features" aria-hidden="true">#</a> features</h4><ul><li>自动关联css，且支持代码分割</li><li>不需要关心class name</li><li>easy to delete</li><li>easy to dynamic styling</li><li>不用跨文件维护</li><li>自动续prefix</li></ul><h4 id="我们可以学到什么" tabindex="-1"><a class="header-anchor" href="#我们可以学到什么" aria-hidden="true">#</a> 我们可以学到什么</h4><ul><li>split的能力是比较友好的</li><li>动态的样式处理形式是友好的，尤其针对主题订制</li></ul><h2 id="js-in-css" tabindex="-1"><a class="header-anchor" href="#js-in-css" aria-hidden="true">#</a> js in css</h2><h3 id="houdini-develop" tabindex="-1"><a class="header-anchor" href="#houdini-develop" aria-hidden="true">#</a> Houdini (develop)</h3><p>为什么需要呢？</p><ul><li>css polyfill比较难，一些能力需要在运行时处理，不能完全通过编译时解决 <ul><li>旧方案：动态兼容的话需要重新计算，引发重排</li><li>新方案：换种干预方式，调用浏览器渲染流程中的一些不能干预的地方进行扩展编写 <ul><li>worklets类似于web workers，不阻塞主线程的执行</li></ul></li></ul></li></ul><p>目标：</p><ul><li>统一各大浏览器的行为——稳定性，例如放弃grid的兼容问题</li><li>运用css polyfill进行新特性的运用——尝鲜</li></ul>',16),r=[n];function c(d,t){return i(),e("div",null,r)}const o=s(l,[["render",c],["__file","cssJs.html.vue"]]);export{o as default};
